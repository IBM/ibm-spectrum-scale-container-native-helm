apiVersion: csi.ibm.com/v1
kind: "CSIScaleOperator"
metadata:
  name: "ibm-spectrum-scale-csi"
  namespace: {{ .Values.csiNamespace | default .Release.Namespace }}
  labels:
    helm.sh/chart: {{ include "ibm-spectrum-scale-csi.chart" . }}
    app.kubernetes.io/name: ibm-spectrum-scale-csi-operator
    app.kubernetes.io/instance: ibm-spectrum-scale-csi-operator
    app.kubernetes.io/managed-by: ibm-spectrum-scale-csi-operator
    release: ibm-spectrum-scale-csi-operator
status: {}
spec:
# The path to the GPFS file system mounted (either remote/local) on the local Spectrum Scale API host machine.
# ==================================================================================
  scaleHostpath: "{{ .Values.primaryFilesystem.mountPoint | default .Values.scaleHostpath }}"

# A passthrough option that distributes an imagePullSecrets array to the containers
# generated by the csi scale operator. Please refer to official k8s documentation for
# your environment for more details. https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
# ==================================================================================
  {{- if .Values.csiImagePullSecrets }}
  imagePullSecrets:
    {{- toYaml .Values.csiImagePullSecrets | nindent 4 }}
  {{- end }}

# Below specifies the details of a SpectrumScale cluster configuration used by the
# plugin. It can have multiple values.
# ==================================================================================
  clusters:
    - id: "{{ .Values.primaryCluster.localClusterId }}"
      secrets: "{{ .Values.primaryCluster.localCsiSecret }}"
      secureSslMode: {{ .Values.primaryCluster.localSecureSslMode }}
      {{- if .Values.primaryCluster.localCAcert }}      
      cacert:  "{{ .Values.primaryCluster.localCAcert }}"
      {{- end }}
      restApi:
        - guiHost: "{{ .Values.primaryCluster.localGuiHost }}"
      primary:
        primaryFs: "{{ .Values.primaryFilesystem.name | default .Values.primaryCluster.primaryFs }}"
        {{- if .Values.primaryCluster.primaryFset }}
        primaryFset: "{{ .Values.primaryCluster.primaryFset }}"
        {{- end }}
        {{- if .Values.primaryCluster.primaryFsetInodeLimit }}
        inodeLimit: "{{ .Values.primaryCluster.primaryFsetInodeLimit }}"
        {{- end }}
        {{- if .Values.primaryCluster.primaryRemoteClusterId }}
        remoteCluster: "{{ .Values.primaryCluster.primaryRemoteClusterId }}"            
        {{- end }}
    {{- if .Values.primaryCluster.primaryRemoteClusterId }}
    - id: "{{ .Values.primaryCluster.primaryRemoteClusterId }}"
      secrets: "{{ .Values.primaryCluster.primaryRemoteCsiSecret }}"
      secureSslMode: {{ .Values.primaryCluster.primaryRemoteSecureSslMode }}
      {{- if .Values.primaryCluster.primaryRemoteCAcert }}
      cacert:  "{{ .Values.primaryCluster.primaryRemoteCAcert }}"
      {{- end }}
      restApi:
        - guiHost: "{{ .Values.primaryRemoteStorageCluster.gui.host | default .Values.primaryCluster.primaryRemoteGuiHost }}"
    {{- end }}
    {{- if .Values.addlRemoteClusters }}
      {{- toYaml .Values.addlRemoteClusters | nindent 4 }}
    {{- end }}

# Attacher image name, in case we do not want to use default image.
# ==================================================================================
#  attacher: "us.gcr.io/k8s-artifacts-prod/sig-storage/csi-attacher:v3.0.0"
{{- if .Values.csiAttacher.image.name }}
  attacher: "{{ .Values.csiAttacher.image.name }}:{{ .Values.csiAttacher.image.tag }}"
{{- end }}
    
# Provisioner image name, in case we do not want to use default image.
# ==================================================================================
#  provisioner: "us.gcr.io/k8s-artifacts-prod/sig-storage/csi-provisioner:v2.0.2"
{{- if .Values.csiProvisioner.image.name }}
  provisioner: "{{ .Values.csiProvisioner.image.name }}:{{ .Values.csiProvisioner.image.tag }}"
{{- end }}

# Driver Registrar image name, in case we do not want to use default image.
# ==================================================================================
#  driverRegistrar: "us.gcr.io/k8s-artifacts-prod/sig-storage/csi-node-driver-registrar:v2.0.1"
{{- if .Values.csiDriverRegistrar.image.name }}
  driverRegistrar: "{{ .Values.csiDriverRegistrar.image.name }}:{{ .Values.csiDriverRegistrar.image.tag }}"
{{- end }}

# SpectrumScale CSI Plugin image name, in case we do not want to use default image.
# ==================================================================================
#  spectrumScale: "quay.io/ibm-spectrum-scale/ibm-spectrum-scale-csi-driver:v2.1.0"
{{- if .Values.csiDriver.image.name }}
  spectrumScale: "{{ .Values.csiDriver.image.name }}:{{ .Values.csiDriver.image.tag | default .Chart.AppVersion }}"
{{- end }}

# attacherNodeSelector specifies on which nodes we want to run attacher sidecar
# In below example attacher will run on nodes which have label as "scale=true"
# and "infranode=2". Can have multiple entries.
# ==================================================================================
{{- if .Values.csiNodeSelectorBase.key }}
  attacherNodeSelector:
    - key: "{{ .Values.csiNodeSelectorBase.key }}"
      value: "{{ .Values.csiNodeSelectorBase.value }}"
  {{- if .Values.csiNodeSelectorAttacher.key }}
    - key: "{{ .Values.csiNodeSelectorAttacher.key }}"
      value: "{{ .Values.csiNodeSelectorAttacher.value }}"
  {{- end }}
{{- end }}

# provisionerNodeSelector specifies on which nodes we want to run provisioner
# sidecar. In below example provisioner will run on nodes which have label as
# "scale=true" and "infranode=1". Can have multiple entries.
# ==================================================================================
{{- if .Values.csiNodeSelectorBase.key }}
  provisionerNodeSelector:
    - key: "{{ .Values.csiNodeSelectorBase.key }}"
      value: "{{ .Values.csiNodeSelectorBase.value }}"
  {{- if .Values.csiNodeSelectorProvisioner.key }}
    - key: "{{ .Values.csiNodeSelectorProvisioner.key }}"
      value: "{{ .Values.csiNodeSelectorProvisioner.value }}"
  {{- end }}
{{- end }}

# pluginNodeSelector specifies nodes on which we want to run plugin daemoset
# In below example plugin daemonset will run on nodes which have label as
# "scale=true". Can have multiple entries.
# ==================================================================================
{{- if .Values.csiNodeSelectorBase.key }}
  pluginNodeSelector:
    - key: "{{ .Values.csiNodeSelectorBase.key }}"
      value: "{{ .Values.csiNodeSelectorBase.value }}"
{{- end }}

# In case K8s nodes name differs from SpectrumScale nodes name, we can provide
# node mapping using nodeMapping attribute. Can have multiple entries.
# ==================================================================================
#  nodeMapping:
#    - k8sNode: "< K8s Node Name >"
#      spectrumscaleNode: "< SpectrumScale Node Name >"
# In case K8s node name start with number then use following node mapping format.
#    - k8sNode: "K8sNodePrefix_< K8s Node Name >"
#      spectrumscaleNode: "< SpectrumScale Node Name >"

# Array of tolerations that will be distribued to CSI pods. Please refer to official
# k8s documentation for your environment for more details.
# https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
# ==================================================================================
{{- if .Values.csiTolerations }}
  tolerations:
    {{- toYaml .Values.csiTolerations | nindent 4 }}
{{- end }}
